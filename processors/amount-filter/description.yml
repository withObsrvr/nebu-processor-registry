processor:
  name: amount-filter
  type: transform
  description: Filter token transfer events by amount (min/max thresholds)
  version: 1.0.0
  language: Go
  license: MIT
  maintainers:
    - withObsrvr

repo:
  github: withObsrvr/nebu-processor-registry
  ref: main

docs:
  quick_start: |
    # Install the processor
    nebu install amount-filter

    # Filter for transfers over 10 XLM (100,000,000 stroops)
    token-transfer --start-ledger 60200000 | amount-filter --min 100000000

    # Filter for specific range
    token-transfer --start-ledger 60200000 | amount-filter --min 100000 --max 10000000

  examples: |
    # Track large USDC transfers (>$100)
    token-transfer --start-ledger 60200000 --follow | \
      usdc-filter | \
      amount-filter --min 1000000000 | \
      json-file-sink --out large-usdc.jsonl

    # Track whale movements (>1000 XLM)
    token-transfer --start-ledger 60200000 --follow | \
      amount-filter --min 10000000000 | \
      nats-sink --subject "whales.transfers"

    # Track micro-payments (<0.01 XLM)
    token-transfer --start-ledger 60200000 | \
      amount-filter --max 100000 | \
      jq -c '{amount: .transfer.amount, asset: .transfer.asset.code}'

    # Filter dust amounts out
    token-transfer --start-ledger 60200000 | \
      amount-filter --min 10000 | \
      postgres-sink --table transfers

    # Range filter (between 1 and 100 XLM)
    token-transfer --start-ledger 60200000 | \
      amount-filter --min 10000000 --max 1000000000 | \
      json-file-sink --out medium-transfers.jsonl

  extended_description: |
    # Amount Filter Transform Processor

    Filters token transfer events based on transfer amount, allowing you to track
    large transfers (whale movements), small transfers (micropayments), or transfers
    within a specific range.

    ---

    ## Amount Units

    All amounts in Stellar are expressed in the smallest unit (stroops for XLM).

    | Asset | Unit Name | Conversion |
    |-------|-----------|------------|
    | XLM | stroop | 1 XLM = 10,000,000 stroops (10^7) |
    | USDC | micro-USDC | 1 USDC = 10,000,000 units (10^7) |
    | Most assets | — | 1 unit = 10,000,000 smallest units (10^7) |

    **Conversion Formula:**
    ```
    stroops = amount × 10,000,000
    ```

    ---

    ## Common Threshold Values

    | Use Case | Human Amount | --min/--max Value |
    |----------|--------------|-------------------|
    | Whale alert (XLM) | > 1,000 XLM | `--min 10000000000` |
    | Large transfer | > 100 XLM | `--min 1000000000` |
    | Medium transfer | > 10 XLM | `--min 100000000` |
    | Small transfer | > 1 XLM | `--min 10000000` |
    | Micropayment | < 0.1 XLM | `--max 1000000` |
    | Dust filter | > 0.001 XLM | `--min 10000` |
    | Large USDC | > $100 | `--min 1000000000` |
    | Medium USDC | > $10 | `--min 100000000` |

    ---

    ## Filter Behavior

    | Configuration | Behavior |
    |---------------|----------|
    | `--min X` | Include events where `amount >= X` |
    | `--max X` | Include events where `amount <= X` |
    | `--min X --max Y` | Include events where `X <= amount <= Y` |
    | Neither | Pass all events through (no filtering) |

    **Inclusive Bounds:** Both --min and --max are inclusive (>= and <=).

    ---

    ## Input Requirements

    This processor expects token-transfer events from stdin. It extracts the
    amount from the following event types:

    | Event Type | Amount Field |
    |------------|--------------|
    | Transfer | `transfer.amount` |
    | Mint | `mint.amount` |
    | Burn | `burn.amount` |
    | Clawback | `clawback.amount` |
    | Fee | `fee.amount` |

    ---

    ## Output Format

    Events are passed through unchanged. Only events matching the amount
    criteria are emitted to stdout.

    **Example with --min 100000000 (10 XLM):**
    ```
    Input:  {"transfer": {"amount": "50000000"}, ...}   → Filtered out (5 XLM)
    Input:  {"transfer": {"amount": "100000000"}, ...}  → Passed (10 XLM, equals min)
    Input:  {"transfer": {"amount": "500000000"}, ...}  → Passed (50 XLM)
    ```

    ---

    ## Configuration

    | Flag | Description | Default |
    |------|-------------|---------|
    | `--min` | Minimum amount threshold (inclusive) | 0 (no minimum) |
    | `--max` | Maximum amount threshold (inclusive) | ∞ (no maximum) |
    | `-q, --quiet` | Suppress startup banner | false |

    ---

    ## Performance

    | Metric | Value | Notes |
    |--------|-------|-------|
    | Throughput | ~100,000 events/sec | Simple numeric comparison |
    | Memory | < 10 MB | Stateless filter |
    | Latency | < 1 ms | No buffering |

    ---

    ## Use Cases

    - **Whale tracking** — Alert on large transfers
    - **Dust filtering** — Exclude tiny amounts from analytics
    - **Micropayment analysis** — Focus on small transfers
    - **Range analysis** — Study transfers in specific brackets
    - **Threshold alerts** — Trigger on amounts above/below limits

    ---

    ## Common Pipelines

    **1. Whale alerts (>1000 XLM):**
    ```bash
    token-transfer --start-ledger 60200000 --follow | \
      amount-filter --min 10000000000 | \
      nats-sink --subject "alerts.whales" --jetstream
    ```

    **2. Large USDC transfers (>$1000):**
    ```bash
    token-transfer --start-ledger 60200000 --follow | \
      usdc-filter | \
      amount-filter --min 10000000000 | \
      postgres-sink --table large_usdc_transfers
    ```

    **3. Exclude dust from analytics:**
    ```bash
    token-transfer --start-ledger 60200000 --end-ledger 60300000 | \
      amount-filter --min 10000 | \
      json-file-sink --out transfers-no-dust.jsonl
    ```

    **4. Bracket analysis (10-100 XLM):**
    ```bash
    token-transfer --start-ledger 60200000 --end-ledger 60300000 | \
      amount-filter --min 100000000 --max 1000000000 | \
      jq -r '.transfer.amount' | \
      sort -n | uniq -c
    ```

    ---

    ## Amount Parsing

    The processor parses amounts as strings (to handle large values) and
    compares them numerically. This correctly handles:

    - Large amounts (> 2^53, JavaScript's safe integer limit)
    - Amounts as strings in JSON (`"amount": "1000000000"`)
    - Amounts as numbers in JSON (`"amount": 1000000000`)

    ---

    ## Comparison with jq Filtering

    This processor is equivalent to:
    ```bash
    token-transfer ... | jq -c 'select(
      (.transfer.amount | tonumber) >= 100000000
    )'
    ```

    **Why use amount-filter instead of jq?**
    - Handles large numbers correctly (jq has precision issues > 2^53)
    - Simpler syntax for threshold filtering
    - Consistent with other nebu processors
    - Faster for simple comparisons

    ---

    ## Limitations

    - Compares raw amount values (no asset-specific decimal handling)
    - Cannot filter by percentage of total supply
    - Single threshold per filter (chain multiple for complex logic)
    - Fee events included (use with usdc-filter to exclude)

    ---

    ## Best Practices

    1. **Know your units:** Always convert to stroops (multiply by 10^7)
    2. **Chain filters:** Use with usdc-filter for asset-specific thresholds
    3. **Quiet mode:** Use `-q` when piping to other processors
    4. **Dust filtering:** Use `--min 10000` to exclude sub-0.001 XLM transfers
    5. **Documentation:** Comment threshold values in scripts for clarity
